# 应用程序性能调优总结--《性能之巅》笔记

## 1. 方法和分析

| 方法             | 类型               |
| ---------------- | ------------------ |
| 线程状态分析     | 观测分析           |
| CPU              | 观测分析           |
| 系统调用分析     | 观测分析           |
| I/O剖析          | 观测分析           |
| 工作负载特征归纳 | 观测分析，容量规划 |
| USB方法          | 观测分析           |
| 向下挖掘分析法   | 观测分析           |
| 锁分析           | 观测分析           |
| 静态性能调优     | 观测分析           |

### 1.1 线程状态分析

#### 1.1.1 状态分类

| 2种状态 | 6种状态  | 说明                                             |
| ------- | -------- | ------------------------------------------------ |
| on  CPU | 执行     | 还可以分内核态和用户态                           |
| off CPU | 可执行   | 在就绪队列中，等待获得CPU                        |
| off CPU | 匿名换页 | 可运行，但是因等待匿名换页受阻                   |
| off CPU | 睡眠     | 等待包括网络，块设备，和数据/文本页换入在内的I/O |
| off CPU | 锁       | 等待获取同步锁                                   |
|         | 空闲     | 等待工作                                         |

减少这些状态的前五项所花费的时间可以让性能得到提升：空闲时间增加，app请求延时变小，可以应对更多负载。

* 执行

  检查执行的是用户态还是内核态耗时，可以确定哪些代码路径消耗CPU，以及消耗了多久。

* 可运行

  在这个状态上耗时，意味着app需要更多的CPU资源。

* 匿名换页

  app缺少可用的主存会引起换页和延时，需要检查整个系统的内存使用情况，和所有对该app做的内存限制。

* 睡眠

  分析阻塞app的资源

* 锁

  识别锁和持有该锁的线程，确定线程持锁这么长时间的原因。原因如果是持锁线程阻塞在另一个锁上，这就需要进一步的梳理。

#### 1.1.3 方法简介

* 执行时间

  可以通过top查看CPU的消耗百分比

* 等待可执行的时间

  内核的schedstat功能会跟踪可运行的线程，信息记录在 /proc/<pid>/schedstat中，perf sched也可用于了解可运行线程和等待线程所花费的时间。

* 等待匿名换页时间

  可以用内核的延时核算（delay accounting）特性来测量，它针对swapping和内存回收的阻塞时间划分了不同的状态。可以使用内核文档里的getdelay.c来获得时间，或者systemtap。

* 睡眠状态所阻塞的时间

  * pidstat -d 可以判断一个进程是在执行磁盘IO还是在睡眠，如果启用了延时核算和IO核算功能，可以得到I/O阻塞的时间。
  * iotop也可以做到上述功能，可以使用跟踪工具调查阻塞的时间。
  * 如果app睡眠时间过久，达到秒级，可以使用pstack调查原因。