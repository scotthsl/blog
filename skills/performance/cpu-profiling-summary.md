# CPU性能调优总结

## 1. 方法

| 方法         | 类型               |
| ------------ | ------------------ |
| 工具法       | 观察分析           |
| USE          | 观察分析，容量规划 |
| 负载特征归纳 | 观察分析           |
| 剖析         | 观察分析           |
| 周期分析     | 观察分析           |
| 性能监控     | 观察分析，容量规划 |
| 静态性能调优 | 观察分析，容量规划 |
| 优先级调优   | 调优               |
| 资源控制     | 调优               |
| CPU绑定      | 调优               |
| 微基准测试   | 实验分析           |
| 扩展         | 容量规划，调优     |

建议按照以下顺序使用上述方法：性能监控，USE，剖析，微型基准测试，静态分析。

## 2. 分析工具

| Linux         | 描述                          |
| ------------- | ----------------------------- |
| uptime        | 平均负载                      |
| vmstat        | 包括系统范围的CPU平均负载     |
| mpstat        | 单个CPU统计信息               |
| sar           | 历史统计信息                  |
| ps            | 进程状态                      |
| top           | 监控每个进程/线程CPU用量      |
| pidstat       | 每个进程/线程CPU用量分解      |
| time          | 给一个命令计时，带CPU用量分解 |
| DTrace， perf | CPU剖析和跟踪                 |
| perf          | CPU性能计数器分析             |

### 2.1 uptime

![捕获](C:\Users\scott\Desktop\捕获.PNG)

uptime提供几个有用的信息，第一个是系统系统当前时间和启动以来的时间，第二个是 平均负载。这里关注平均负载：

`load average: 0.52, 0.58, 0.59`

这三个数值代表系统1分钟，5分钟，15分钟的负载。平均负载大于CPU数量表示CPU不足以服务线程，有线程在runqueue里等待。如果小于CPU数量，则代表还有一些余量，线程可以在他们想要的时间在CPU上运行。

 但是目前Linux把在不可中断状态执行磁盘I/O的任务也计入了平均负载。这意味着平均负载再也不能单用来表示CPU余量或者饱和度，因为不能单从这个值推断出CPU或者磁盘负载。由于负载可能在CPU和磁盘之间不断变化，比较这三个平均负载数值也变得困难了。

在Linux上最好通过其它一些指标了解CPU负载，例如vmstate和mpstat。

### 2.2 vmstate

![1](C:\Users\scott\Desktop\1.PNG)

